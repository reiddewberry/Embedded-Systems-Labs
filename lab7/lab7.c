//Chandler Reid Dewberry
//ECE486 Lab 7
//4/14/17

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

/*3 Global Variables
*fileName = Array to store the name of the file wanting to be opened
*refArray = Array created for the Main Memory Refs and values
*refArrayHeight = int value of the total height needed to store all the values*/
char fileName[100];
char *refArray[1000][2];
int refArrayHeight;

int initialInput(int *mainMSize, int *cacheMSize, int *blockSize, int *setAsso, char *replacePol){
    /*This prompts the user for all needed data and stores data in variables. It also returns
    *an integer value used as the cache memory height to create our cache memory array*/
    printf("Enter the size of main memory in bytes: ");
    scanf("%d", &*mainMSize);
    printf("Enter the size of the cache in bytes: ");
    scanf("%d", &*cacheMSize);
    printf("Enter the cache block/line size: ");
    scanf("%d", &*blockSize);
    printf("\nEnter the degree of set-associativity (input n for an n-way set-associative mapping): ");
    scanf("%d", &*setAsso);
    printf("Enter the replacement policy (L = LRU, F = FIFO): ");
    scanf(" %c", &*replacePol);
    printf("Enter the name of the input file containing the list of memory references generated by the CPU: ");
    scanf(" %s", fileName);
    return (*cacheMSize / *blockSize);
}

int printInitials(int *mainMSize, int *blockSize, int *cacheMSize, int *setAsso, int *cacheMHeight){
    /*This prints the first set of data calculated from the user
    *Total number of address lines, number of offset bits,
    *number of index bits, number of tage bits, and
    *the total cache size required. It also passes back an
    *int value of the number of tag bits*/
    double totalNumOfAddrLines = (log(*mainMSize) / log(2));
    double numOffsetBits = (log(*blockSize) / log(2));
    double numIndexBits = (log((*cacheMSize/ *blockSize) / *setAsso) / log(2));
    double numTagBits = (totalNumOfAddrLines - (numOffsetBits + numIndexBits));
    printf("\nSimulator Output:\n");
    printf("Total address lines required = %d\n", (int)totalNumOfAddrLines);
    printf("Number of bits for offset = %d\n", (int)numOffsetBits);
    printf("Number of bits for index = %d\n", (int)numIndexBits);
    printf("Number of bits for tag = %d\n", (int)numTagBits);
    printf("Total cache size required = %d bytes\n", (int)(*cacheMSize + ((*cacheMHeight/8)*2) + numTagBits));
    return (int)numTagBits;
}

void createRefChart(fileName){
    /*Initializes and opens the file the user inputs*/
    FILE *inputFile;
    inputFile = fopen(fileName,"r");
    /*temporary char variable to pass in the values from the input file*/
    char *tempParser;
    /*used to read in the integer value from the input file*/
    int intTempParser;
    /*reads past the first value for the reference array height*/
    fscanf(inputFile, " %d", &intTempParser);
    /*loops through the file until it has read all that is there*/
    for(int i = 0; i < refArrayHeight; i=i+1){
        /*finds the first input, an R or W*/
        fscanf(inputFile, " %c", &tempParser);
        /*Stores it in the corresponding column in the reference array*/
        refArray[i][0] = tempParser;

        /*finds the second input, an integer value*/
        fscanf(inputFile, " %d", &intTempParser);
        /*Stores it in the corresponding column in the reference array as a char value*/
        refArray[i][1] = (intTempParser + '0');
    }
    /*closes the file*/
    fclose(inputFile);
    return 0;
}

int dataToCache(int *RorW,int *mmBlkNum, int *numOfCMSets, int *numOfIndexBits, char *replacePol, int *setAsso, int cacheMArr[][6]){
    /*HorM holds the value for if there is a hit. Hit=1; Miss=0*/
    int HorM = 0;
    /*runs if set-associativity is greater than 1*/
    if(*setAsso > 1){
        /*iterates through the cache memory blocks within the cache memory
        * set that is determined from the user given values*/
        for(int i=((*mmBlkNum % *numOfCMSets) * *setAsso); i < (((*mmBlkNum % *numOfCMSets) * *setAsso) + (*setAsso)); i++){
            /*Checks if the Valid Bit = 1 and if the Tag is the same as what we are looking for*/
            if(cacheMArr[i][2]==1 && cacheMArr[i][3]==(int)( *mmBlkNum/(pow(2, *numOfIndexBits)) )){
                /*sets HorM as 1 to say it is a hit*/
                HorM = 1;
                /*sets the cache array data to the current mm block number*/
                cacheMArr[i][4] = *mmBlkNum;
                /*if the replacement policy is LRU the current cache block # to least recently used by increasing the others value by 1*/
                if(*replacePol == 'L'){
                    for(int j=((*mmBlkNum % *numOfCMSets) * *setAsso); j < (((*mmBlkNum % *numOfCMSets) * *setAsso) + (*setAsso)); j++){
                        if(i == j){
                            cacheMArr[j][5] = 0;
                        }
                        else{
                            cacheMArr[j][5] = cacheMArr[j][5] + 1;
                        }
                    }
                }
                /*if it is a write function is sets the dirty bit to '1'*/
                char temp = refArray[*RorW][0];
                if(temp == 'W'){
                    cacheMArr[i][1] = 1;
                }
                else{cacheMArr[i][1] = 0;};
                break;
            }
        }
    }
    /*if set associativity is equal to 1*/
    else{
        /*analyzes the cm block # to determine if the valid bit is 1 and if the tag is the same*/
        if(cacheMArr[(*mmBlkNum % *numOfCMSets)][2]==1 && cacheMArr[(*mmBlkNum % *numOfCMSets)][3]== (int)( *mmBlkNum/(pow(2, *numOfIndexBits)) )){
            /*Sets hit or miss as hit*/
            HorM = 1;
        }
        /*If it's a write, it sets the Dirty bit to '1'*/
        char temp = refArray[*RorW][0];
        if(temp=='W'){
            cacheMArr[(*mmBlkNum % *numOfCMSets)][1] = 1;
        }
        else{cacheMArr[(*mmBlkNum % *numOfCMSets)][1] = 0;};
    }

    /*if it is a miss it runs this*/
    if(HorM==0){
        if(*setAsso > 1){ /*Checks if the Set-Association is greater than 1*/
            if(*replacePol == 'F'){ /*Checks is the Replacement Policy is FIFO*/
                /*Iterates through the blocks within whatever set the current main memory reference is in*/
                for(int i=((*mmBlkNum % *numOfCMSets) * *setAsso); i < (((*mmBlkNum % *numOfCMSets) * *setAsso) + (*setAsso)); i++){
                    /*checks to see if the first values in the cache memory array column for replacement policy is '1'
                    * is it is it checks if the value currently being looked at is a '0' or '1'.
                    * if it is a '0' set the values for that row and change the '0' to a '1'.
                    * if it gets to the last value and it's still a '1', set the first value to '0'
                    * and update the row associated*/
                    if(cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][5]==1){
                        if(cacheMArr[i][5]==0){
                            char temp = refArray[*RorW][0];
                            if(temp=='W'){
                                cacheMArr[i][1] =  1;
                            }
                            else{cacheMArr[i][1] = 0;};
                            cacheMArr[i][2] = 1;
                            cacheMArr[i][3] = (int)( *mmBlkNum/(pow(2, *numOfIndexBits)) );
                            cacheMArr[i][4] = *mmBlkNum;
                            cacheMArr[i][5] = 1;
                            break;
                        }
                        if(i == (((*mmBlkNum % *numOfCMSets) * *setAsso) + (*setAsso-1)) && cacheMArr[i][5]==1){
                            char temp = refArray[*RorW][0];
                            if(temp=='W'){
                                cacheMArr[i][1] =  1;
                            }
                            else{cacheMArr[i][1] = 0;};
                            cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][2] = 1;
                            cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][3] = (int)( *mmBlkNum/(pow(2, *numOfIndexBits)) );
                            cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][4] = *mmBlkNum;
                            cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][5] = 0;
                        }
                    }
                    /*if it begins with a '0', iterate through the set and check for a '1'.
                    * if a '1' is found, set it to '0' and set that row data to the current.
                    * if it gets to the last value and it is also a '0', set the first value
                    * to '1' and update the first value with the current data*/
                    else{
                        if(cacheMArr[i][5]==1){
                            char temp = refArray[*RorW][0];
                            if(temp=='W'){
                                cacheMArr[i][1] =  1;
                            }
                            else{cacheMArr[i][1] = 0;};
                            cacheMArr[i][2] = 1;
                            cacheMArr[i][3] = (int)( *mmBlkNum/(pow(2, *numOfIndexBits)) );
                            cacheMArr[i][4] = *mmBlkNum;
                            cacheMArr[i][5] = 0;
                            break;
                        }
                        if(i == (((*mmBlkNum % *numOfCMSets) * *setAsso) + (*setAsso-1)) && cacheMArr[i][5]==0){
                            char temp = refArray[*RorW][0];
                            if(temp=='W'){
                                cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][1] =  1;
                            }
                            else{cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][1] = 0;};
                            cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][2] = 1;
                            cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][3] = (int)( *mmBlkNum/(pow(2, *numOfIndexBits)) );
                            cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][4] = *mmBlkNum;
                            cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][5] = 1;
                        }
                    }
                }
            }
            /*Runs if the Replacement Policy is LRU*/
            else{
                /*initializes a low and high variable to store the lowest and highest LRU value
                * this is used to determine which value was least recently used*/
                int high = ((*mmBlkNum % *numOfCMSets) * *setAsso);
                int low = ((*mmBlkNum % *numOfCMSets) * *setAsso)+1;
                /*iterates through the current cache memory set and finds
                * the lowest and highest values*/
                for(int i=1+((*mmBlkNum % *numOfCMSets) * *setAsso); i < (((*mmBlkNum % *numOfCMSets) * *setAsso) + (*setAsso)); i++){
                    if(cacheMArr[high][5] < cacheMArr[i][5]){
                        high = i;
                    }
                    if(cacheMArr[low][5] > cacheMArr[i][5]){
                        low = i;
                    }
                    else{}
                }

                /*if the lowest and highest are both equal to '0', then this is the first run and change
                * the first cm block of that set to current values and increase all other LRU values of
                * the cm blocks of that set to 1*/
                if(cacheMArr[low][5]==0 && cacheMArr[high][5]==0){
                    for(int i=((*mmBlkNum % *numOfCMSets) * *setAsso); i < (((*mmBlkNum % *numOfCMSets) * *setAsso) + (*setAsso)); i++){
                        cacheMArr[i+1][5] = cacheMArr[i+1][5] + 1;
                    }
                    char temp = refArray[*RorW][0];
                    if(temp=='W'){
                        cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][1] =  1;
                    }
                    else{cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][1] = 0;};
                    cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][2] = 1;
                    cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][3] = (int)( *mmBlkNum/(pow(2, *numOfIndexBits)) );
                    cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][4] = *mmBlkNum;
                    cacheMArr[((*mmBlkNum % *numOfCMSets) * *setAsso)][5] = 0;
                }
                /*if the lowest and highest are different run this*/
                else{
                    /*iterate through the cm set needed and find the least recently used.
                    * It then sets that row's values to the current values and
                    * increases all other rows LRU value by '1'*/
                    for(int i=((*mmBlkNum % *numOfCMSets) * *setAsso); i < (((*mmBlkNum % *numOfCMSets) * *setAsso) + (*setAsso)); i++){
                        if(cacheMArr[i][0] == cacheMArr[high][0]){
                            char temp = refArray[*RorW][0];
                            if(temp=='W'){
                                cacheMArr[high][1] =  1;
                            }
                            else{cacheMArr[high][1] = 0;};
                            cacheMArr[high][2] = 1;
                            cacheMArr[high][3] = ((int)( *mmBlkNum/(pow(2, *numOfIndexBits)) ));
                            cacheMArr[high][4] = *mmBlkNum;
                            cacheMArr[high][5] = 0;
                        }
                        else{
                            cacheMArr[i][5] = cacheMArr[i][5] + 1;
                        }
                    }
                }
            }
        }
        /*if it is direct mapped, this runs.
        * it sets whatever cm array row is associated with the
        * cm block # to what the current values are*/
        else{
            char temp = refArray[*RorW][0];
            if(temp=='W'){
                cacheMArr[(*mmBlkNum % *numOfCMSets)][1] =  1;
            }
            else{cacheMArr[(*mmBlkNum % *numOfCMSets)][1] = 0;};
            cacheMArr[(*mmBlkNum % *numOfCMSets)][2] = 1;
            cacheMArr[(*mmBlkNum % *numOfCMSets)][3] = (int)( *mmBlkNum/(pow(2, *numOfIndexBits)) );
            cacheMArr[(*mmBlkNum % *numOfCMSets)][4] = *mmBlkNum;
            }
    }
    /*returns if there was a hit*/
    return HorM;
}

int printRef(int *cacheMSize, int *blockSize, int *setAsso, char *replacePol, int cacheMArr[][6]){
    /*variables used to store Hit or Miss data
    * HorM = stores hit or miss as we go through the memory references
    * HorMTotal = stores every hit that is recorded
    * HorMIdeal = stores the max amount of hits possible*/
    int HorM=0;
    int HorMTotal=0;
    int HorMIdeal=0;
    /*This array is the height of the main memory references and is
    * used to store the main memory block #s*/
    int mmBlkNumArr[refArrayHeight];
    /*prints the initial line of text for the user*/
    printf("\nmain memory address\t");
    printf("mm blk #\tcm set #\t");
    printf("cm blk #\thit/miss");
    /*iterates through the reference values read in from th input file*/
    for(int i = 0; i < refArrayHeight; i++){
        /*variables used to store certain data:
        * mmAddr = stores the main memory address, mmBlkNum = main memory block #,
        * mmBlkNumArr stores each main memory block number as it is read in
        * numOfCMSets = Number of Cache memory sets, cmSetNum = Cache memory set #,
        * cmBlkNum = cache memory block #, numIndexBit = the number of index bits*/
        int mmAddr = (refArray[i][1]-'0');
        int mmBlkNum = (mmAddr/ *blockSize);
        mmBlkNumArr[i] = mmBlkNum;
        int numOfCMSets = (( *cacheMSize/ *blockSize)/ *setAsso);
        int cmSetNum = (mmBlkNum%numOfCMSets);
        int cmBlkNum = (cmSetNum* *setAsso);
        int numIndexBits = (log((*cacheMSize/ *blockSize) / *setAsso) / log(2));

        /*prints the data for the mmAddr, mmBlkNum, cmSetNum, cmBlkNum*/
        printf("\n");
        printf("\t%d \t\t  %d \t\t   %d", mmAddr, mmBlkNum, cmSetNum);
        if(*setAsso > 1){
            printf("\t\t  %d-%d     \t ", cmBlkNum, (cmBlkNum+(*setAsso-1)) );
        }
        else{
            printf("\t\t    %d  \t\t ", cmBlkNum);
        }
        /*runs the dataToCache() function to determine if it it a hit or a miss
        * and stores the values into HorM*/
        HorM = dataToCache(&i, &mmBlkNum, &numOfCMSets, &numIndexBits, &*replacePol, &*setAsso, cacheMArr);
        /*prints "hit" or "miss" depending on if it was*/
        if(HorM==1){
            HorMTotal += 1;
            printf("hit");
        }
        else{printf("miss");}
    }

    /*temporary integer used to sort the main memory block number array*/
    int temp;
    /*a bubble sort to sort the array into lowest to highest order*/
    for(int i=0; i <(refArrayHeight); i++){
        for(int j=0; j < (refArrayHeight-i-1); j++){
            if(mmBlkNumArr[j] > mmBlkNumArr[j+1]){
                temp = mmBlkNumArr[j];
                mmBlkNumArr[j] = mmBlkNumArr[j+1];
                mmBlkNumArr[j+1] = temp;
            }
        }
    }
    /*the number of repetitions is counted to
    * determine the ideal number of hits*/
    for(int i=0; i<refArrayHeight-1; i++){
        if(mmBlkNumArr[i] == mmBlkNumArr[i+1]){
            HorMIdeal += 1;
        }
    }
    /*prints the highest possible hit rate (ideal)*/
    printf("\n\nHighest possible hit rate = %d/%d = %d%\n", HorMIdeal, refArrayHeight, ((HorMIdeal*100)/refArrayHeight));

    /*returns int value HorMTotal*/
    return HorMTotal;
}

void printHitAndCache(int cacheMArr[][6], int *cacheMHeight, int *numOfTagBits, int *actualHorM){
    /*prints the actual hit rate*/
    printf("Actual hit rate = %d/%d = %d%\n", *actualHorM, refArrayHeight, ((*actualHorM *100) / refArrayHeight));

    /*prints the top line of the cache memory array with specific spacing*/
    printf("\nCache blk #\t");
    printf("dirty bit \t valid bit\t");
    printf("  tag \t\t Data");
    /*iterates through the array for printing*/
    for(int i=0; i<*cacheMHeight; i++){
        /*prints the cache blk #, dirty bit, and valid bit*/
        printf("\n      %d \t   %d \t\t   %d\t\t  ", cacheMArr[i][0], cacheMArr[i][1], cacheMArr[i][2]);
        /*prints the value for the tag or prints x's in it's place*/
        if(cacheMArr[i][3] != -1){
            int binPrint = cacheMArr[i][3];
            for(int j=(*numOfTagBits); j>0; j--){
                if((binPrint & (1 << j-1)) != 0){
                    printf("1");
                }
                else{printf("0");}
            }
        }
        else{
            for(int j=0; j< *numOfTagBits; j++){
                printf("x");
            }
            printf("\t");
        }
        /*prints the value for the data or "xxx" in it's place*/
        if(cacheMArr[i][4] != -1){
            printf("\t      mm blk # %d", cacheMArr[i][4]);
        }
        else{
            printf("\t xxx");
        }
    }
}

int main(){
    char run = 'y';  /*Initializes a variable to keep the program running as long as the user wants*/
    while(run=='y'){
    /*Initializing variables needed to be obtained from the user
    *mainMSize = Main Memory Size, cacheMSize = Cache Memory Size
    *blockSize = Block Size, setAsso = Set-Associativity
    *
    *replacePol = Replacement Policy */
    int mainMSize, cacheMSize, blockSize, setAsso;
    char replacePol;

    /*cacheMHeight is initialized and given the value of the return of the function: initialInput().
    *initialInput() prompts the user and obtains all needed input.*/
    int cacheMHeight = initialInput(&mainMSize, &cacheMSize, &blockSize, &setAsso, &replacePol);

    /*This block opens the given file finds the needed
    *height of the cacheMArr (Cache Memory Array)*/
    FILE *inputFile;
    int intTemp =0;
    inputFile = fopen(fileName, "r");
    fscanf(inputFile, " %d", &intTemp);
    refArrayHeight = (intTemp);
    fclose(inputFile);

    /*cacheMArr is created to be our representation of cache memory and
    *where to store out values from the user as we read them*/
    int cacheMArr[cacheMHeight][6];
    /*This sets all the values to blank values*/
    for(int i=0; i<cacheMHeight; i++){
        cacheMArr[i][0] = i;
        cacheMArr[i][1] = 0;
        cacheMArr[i][2] = 0;
        cacheMArr[i][3] = -1;
        cacheMArr[i][4] = -1;
        cacheMArr[i][5] = 0;
    }
    /*This function creates the main memory reference chart storing all data from the user*/
    createRefChart(fileName);
    /*printInitials() prints the initial values of our data to the user and then return
    * the number of tag bits which is stored in the variable numOfTagBits.*/
    int numOfTagBits = printInitials(&mainMSize, &blockSize, &cacheMSize, &setAsso, &cacheMHeight);
    /*printRef() prints the memory reference chart to the user and returns the value for
    * the actual number of hits using whatever set-associativity and replacement policy*/
    int actualHorM = printRef(&cacheMSize, &blockSize, &setAsso, &replacePol, cacheMArr);
    /*printHitAndCache() prints to the user the hit actual hit rate and the final
    * status of the cache memory array*/
    printHitAndCache(cacheMArr, &cacheMHeight, &numOfTagBits, &actualHorM);

    /*Prompts the user if they want to continue to a new file and stores
    * the response and either continues or terminates the program*/
    printf("\n\nContinue? (y = yes, n = no): ");
    scanf(" %c", &run);
    printf("\n");
    }
    return 0;
}
